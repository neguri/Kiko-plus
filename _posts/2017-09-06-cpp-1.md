---
layout: post
title: "CPP 연습 (1)"
description: "cpp 연습"
date: 2017-09-06
tags: [cpp]
comments: false
share: false
---

##### 6.2.3 클래스 크기
```cpp
#include <iostream>
class CEmpty {
public:
    CEmpty(){};
    ~CEmpty(){};
};

class CVirtualEmpty {
public:
    CVirtualEmpty(){};
    virtual ~CVirtualEmpty(){};
};

int main()
{
    cout<<sizeof(CEmpty)<<endl;
    cout<<sizeof(CVirtualEmpty)<<endl;
    return 0;
}
```
실행결과는 1,4가 나온다.
멤버가 없는 클래스라고 하더라도 메모리 어딘가를 점유해야 하므로 1바이트가 잡히고,가상함수가 하나라도 있는 경우엔 vfptr이 생성되므로 4바이트가 잡히게 된다.  
sizeof 의 경우 런타임에 실행되는 것이 아니라 컴파일 시점에 이미 계산되기 때문에 성능에 영향을 주지 않는다.


##### 6.3.1 암시적인 생성자와 소멸자

코드상에서 명시적으로 생성자가 선언되어 있지 않더라도 생성자가 필요한 경우 컴파일러는 암시적인 생성자/소멸자를 생성한다.  
(최신 컴파일러는 쓸데없는 암시적 생성자/소멸자를 생성하지 않는다.)

```cpp
class CTestP3 {
    public: int data;
};
class CTest3: public CTestP3 {
    public: int data;
}
```

P 클래스와 D 클래스 모두 생성자가 없다. 컴파일러는 생성자를 만들지 않는다.

```cpp
class CTestP5 {
public: 
    CTestP5(){} 
    int data;
};
class CTest5: public CTestP5 {
    public: int data;
}
```
D 클래스에는 생성자가 없지만 P 클래스에 생성자가 있다. 생성자가 있으므로 P 클래스의 생성자는 호출되어야 하는데 자식 클래스인 D 클래스의 생성자에서 P 클래스의 생성자를 호출해야 한다. 
따라서 D 클래스의 생성자를 컴파일러가 만들어 준다. 일반적으로 P 클래스의 생성자 -> D 클래스의 생성자 순서로 호출 된다고 생각되지만, 실제는 D 클래스 생성자가 P 클래스의 생성자를 호출해 주게 된다.
소멸자도 동일한 방식이다. 


##### 6.3.2 생성자와 소멸자의 호출 순서

```cpp
D_Class()
[ // 선처리 영역
  부모 클래서의 생성자 호출
  멤버가 클래스 타입일 경우 생성자 호출
  ... 기타 작업들
]
{
  자식 클래스의 생성자 호출
}
```
컴파일러에서 자동으로 선처리 영역이 생성된다. 
생성자 호출은 D -> P 순서가 되지만, 실행되는 순서는 P -> D 가 된다.


```cpp
~D_Class()
{
  자식 클래스의 소멸자 호출
}
[ // 후처리 영역
  부모 클래서의 생성자 호출
  멤버가 클래스 타입일 경우 소멸자 호출
  ... 기타 작업들
]

```
소멸자도 같은 원리이다.
왜 이렇게 하는지? 다음을 보면 당연한 원리이다.
```cpp
#include <iostream>
class CParent {
public:
    CParent() {
        m_pInt = new int;
    }
    ~CParent() {
        delete m_pInt;
    }
    int* m_pInt;
};

class CChild : public CParent {
public:
    CChild() {
        *m_pInt = 9999;
    }
    ~CChild() {
        std::cout<<*m_pInt<<endl;
    }
};

int main()
{
    CChild c;
    return 0;
}
```
D 클래스에서 m_pInt 를 접근해야 하므로 P 클래스의 생성자가 먼저 호출 되어야 하고
소멸자에서도 m_pInt를 해제하는 P 클래스의 소멸자는 나중에 실행되어야 한다.
