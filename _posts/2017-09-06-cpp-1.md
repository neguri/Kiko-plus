---
layout: post
title: "CPP 연습 (1)"
description: "cpp 연습"
date: 2017-09-06
tags: [cpp]
comments: false
share: false
---


##### 6.2.3 클래스 크기
```cpp
#include <iostream>

using namespace std;

class CEmpty {
public:
    CEmpty(){};
    ~CEmpty(){};
};

class CVirtualEmpty {
public:
    CVirtualEmpty(){};
    virtual ~CVirtualEmpty(){};
};

int main()
{
    cout<<sizeof(CEmpty)<<endl;
    cout<<sizeof(CVirtualEmpty)<<endl;
    return 0;
}
```
실행결과는 1,4가 나온다.
멤버가 없는 클래스라고 하더라도 메모리 어딘가를 점유해야 하므로 1바이트가 잡히고, 
가상함수가 하나라도 있는 경우엔 ==vfptr==이 생성되므로 4바이트가 잡히게 된다. 
==sizeof== 의 경우 런타임에 실행되는 것이 아니라 컴파일 시점에 이미 계산되기 때문에 성능에 영향을 주지 않는다.


##### 6.3.1 암시적인 생성자와 소멸자

코드상에서 명시적으로 생성자가 선언되어 있지 않더라도 생성자가 필요한 경우 컴파일러는 암시적인 생성자/소멸자를 생성한다.  
(최신 컴파일러는 쓸데없는 암시적 생성자/소멸자를 생성하지 않는다.)

```cpp
class CTestP3 {
    public: int data;
};
class CTest3: public CTestP3 {
    public: int data;
}
```

P 클래스와 D 클래스 모두 생성자가 없다. 컴파일러는 생성자를 만들지 않는다.

```cpp
class CTestP5 {
public: 
    CTestP5(){} 
    int data;
};
class CTest5: public CTestP5 {
    public: int data;
}
```
D 클래스에는 생성자가 없지만 P 클래스에 생성자가 있다. 생성자가 있으므로 P 클래스의 생성자는 호출되어야 하는데  
자식 클래스인 D 클래스의 생성자에서 P 클래스의 생성자를 호출해야 한다. 
따라서 D 클래스의 생성자를 컴파일러가 만들어 준다. 일반적으로 P 클래스의 생성자 -> D 클래스의 생성자 순서로 호출 된다고 생각되지만, 실제는 D 클래스 생성자가 P 클래스의 생성자를 호출해 주게 된다.
소멸자도 동일한 방식이다. 

