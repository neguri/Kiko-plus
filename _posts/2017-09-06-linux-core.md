---
layout: post
title: "linux tip"
description: "linux tip을 적은 페이지"
date: 2017-09-06
tags: [linux]
comments: false
share: false
---

리눅스를 사용하면서 알게된 팁.

--- 

## 1. core

**segmentation fault** 가 발생하면 당황하게 되는데 이때 당황하지 말고 **gdb**를 이용해서 확인해 보자.
> 어느분 말씀으론 인류가 정복하기 힘든 세가지가 linux kernel, vi editor, gdb 라고 하는데...

segmentation fault가 발생하면 다음 순서로 진행을 해보자
* dump size를 크게 잡기
* core 와 binary 올리기
* backtrace 보기
* f #n 으로 원하는 프레임으로 이동하기
* p val로 변수 값 확인해 보기

```
$ ulimit -c unlimited
$ gdb ../bcov/bcov ./core
$ bt
$ f2
$ p cond
```

``` cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void c(){
 vector<int> v ;
 fill_n(v.begin(),4,10);
}

void b(){ c(); }
void a(){ b(); }


int main()
{
    vector<int> v = {0,1,2,3,4,5,6,7,8,9};
    fill_n(v.begin(),4,100);
    for( auto a : v) cout<<a<<"  ";
    cout<<endl;
    a();
    cout<<endl;
    return 0;
}
```

``` bash
// 실행하면 core 가 생김. 실행하기 전에 coredump 생성될 수 있도록 "ulimit -c unlimited" 를 실행해 줘야 함
 

$ g++ -g -std=c++11 fill_n.cpp
$ ./a.out
100  100  100  100  4  5  6  7  8  9
세그멘테이션 오류 (core dumped)


// core file 생성됨을 확인
$ ll
-rwxrwxr-x 1 70104  9월  5 13:17 a.out*
-rw------- 1 561152  9월  5 13:17 core
-rw-rw-r-- 1 357  9월  5 13:07 fill_n.cpp

// gdb 로 ./a.out 과 ./.core를 로딩. 실행파일을 먼저 부르고 그 다음에 core를 
$ gdb ./a.out ./core
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
Reading symbols from ./a.out...done.
[New LWP 6759]
Core was generated by `./a.out.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x000000000040120a in std::__fill_n_a<int*, int, int> (__first=0x0, __n=4, __value=@0x7fff2bd0241c: 10) at /usr/include/c++/5/bits/stl_algobase.h:770
770             *__first = __tmp;

// bt를 하면 stack frame 이 보여짐
(gdb) bt

#0  0x000000000040120a in std::__fill_n_a<int*, int, int> (__first=0x0, __n=4, __value=@0x7fff2bd0241c: 10) at /usr/include/c++/5/bits/stl_algobase.h:770
#1  0x0000000000400eb0 in std::fill_n<__gnu_cxx::__normal_iterator<int*, std::vector<int, std::allocator<int> > >, int, int> (__first=<error reading variable: Cannot access memory at address 0x0>, __n=4,
    __value=@0x7fff2bd0241c: 10) at /usr/include/c++/5/bits/stl_algobase.h:805
#2  0x0000000000400b84 in c () at fill_n.cpp:11
#3  0x0000000000400bd1 in b () at fill_n.cpp:15
#4  0x0000000000400bdd in a () at fill_n.cpp:19
#5  0x0000000000400cfd in main () at fill_n.cpp:33
 

// 1 번 frame을 보자고 . f 2는 2번. 
(gdb) f 1
#1  0x0000000000400eb0 in std::fill_n<__gnu_cxx::__normal_iterator<int*, std::vector<int, std::allocator<int> > >, int, int> (__first=<error reading variable: Cannot access memory at address 0x0>, __n=4,
    __value=@0x7fff2bd0241c: 10) at /usr/include/c++/5/bits/stl_algobase.h:805
805           return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));


// p 명령어는 메모리를 보는것 . __tmp 를 보고자 함. 값은 10이 들어 있음 . 소스가 fill_n(v.begin(), 4,10)이므로 세번째 파라미터 값이 10 이란 뜻
(gdb) p __tmp
$1 = 10
(gdb)
```




## 2. 명령어
### 1. du

디렉토리의 크기를 알고 싶을때
```
$ du -hs
$ du -h --max-depth=1
```

### 2. python version

```
alias python="/usr/bin/python"
alias python="/home/neguri/anaconda3/python"
```

3.6을 쓰고 싶은데 poky 빌드를 하려면 v2가 필요하다고 한다.

## 3. 쉘
1. zsh
> zsh를 설치하고, bash를 zsh로 변경
> $ sudo apt-get install zsh
> $ chsh -s /usr/bin/zsh
> $ echo $SHELL
>   /usr/bin/zsh
> oh-my-zsh 를 설치
>  $ curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh
