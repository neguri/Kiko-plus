---
layout: post
title: "python (iterator, generator)"
description: "python basic study"
date: 2019-07-25
tags: [python]
comments: false
share: false
---
### Iterator

#### Iterable vs Iterator
> Iterable 은 값을 한번에 하나씩 반환 할 수 있는 객체. 즉 한번에 하나씩 반환 할 수도 있고 여러개를 반환 할 수도 있음. 예를 들면 list , string, tuple 같은 sequence 자료형이나 dictionary 같은 non-sequence 자료형도 포함됨. 그리고 open files, open sockes 같은 것도 포함되며, 클래스에 &#95;&#95;iter&#95;&#95; 나 &#95;&#95;getitem&#95;&#95; 메서드를 구현한 경우도 **iterable** 하다고 볼수 있음.

> 하지만 **Iterator**는 값을 하나씩만 반환하는 개체임. 그래서 Iterable 하다고 해서 Iterator 가 되는 것은 아님.

``` python
## iterable

def main():
    x = [1,2,3]
    y = {'red':1 , 'yellow':2, 'green':3}
    
    x_iterator = iter(x)
    y_iterator = iter(y)
    
    
    print("=== print type ===")
    
    print("list type %s" % type(x))
    print("dict type %s" % type(y))
    print("list iter type %s" % type(x_iterator))
    print("dict iter type %s" % type(y_iterator))
    
    print("=== print next ===")
    print("list iterator next  %s" % next(x_iterator))
    print("list iterator next  %s" % next(x_iterator) ) 
    print("dict iterator next %s" % next(y_iterator))
    print("list next %s" % next(x))
    print("dict next %s" % next(y))
    
if __name__ == "__main__":
    main()
```
> 실행 결과는 다음과 같음.
> ``` bash
>=== print type ===
>list type <class 'list'>
>dict type <class 'dict'>
>list iter type <class 'list_iterator'>
>dict iter type <class 'dict_keyiterator'>
>=== print next ===
>list iterator next  1
>list iterator next  2
>dict iterator next red
> TypeError Traceback (most recent call last)
> ---> 22     print("list next %s" % next(x))
>      23     print("dict next %s" % next(y))
> 
> TypeError: 'list' object is not an iterator> 
>```

> list 자체로서는 iterator 가 아니깨문에 발생하는 오류임. 그래서 iterable 개체를 하나씩 출력할 때는 iterator 개체로 변환하는 과정이 필요함. ( for loop에서 iterable 개체를 iter로 변환하지는 않는데, 그 이유는 for문에서 자동으로 iterable 개체를 임시 iterator로 변환하기 때문임.)

#### Iterator

> iterator의 특징은 두가지로 설명될 수 있는데, 
>* 이미 반환한 상태를 가지고 있고, 어디서 부터 반환해야 하는지를 저장. 
>* next 함수를 통해 값을 순차적으로 가지고 옴.  

그런데 순차적 값을 가지고 오다가 더이상 못 가지고 오는 경우 **StopIeration** 예외를 발생 시킴.

``` python
# iterator

def main():
    x = [1,2,3]
    x_iterator = iter(x)
    
    print(next(x_iterator))
    print(next(x_iterator))
    print(next(x_iterator))
    print(next(x_iterator))

if __name__ == "__main__":
    main()
```

``` bash
<ipython-input-22-fe35ee033ee9> in main()
      8     print(next(x_iterator))
      9     print(next(x_iterator))
---> 10     print(next(x_iterator))
     11 
     12 if __name__ == "__main__":

StopIteration:
```
> 숫자 3 까지는 출력 되지만 그 다음엔 **StopIteration** 이 발생함. for loop에서는 내부적으로 StopIteration이 처리되어 있음

  
---  

### Generator

> Generator의 사전적인 정의는 '루프의 반복 동작을 제어하는 특수한 함수' 라고 함. 그리고 파이썬에서는 '제네레이터는 이터레이터를 반환하고 yield 구문을 포함하는 함수(python2)'라고 되어 있음. python3는 '제네레이터는 제네레이터 이터레이터를 반환하는 함수' 라고 정의하고 있음 (무슨 말인지.)

#### Generator Iterator



update(2019-07-25. 출처:파이썬답게 코딩하기)