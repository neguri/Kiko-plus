---
layout: post
title: "python (concurrency)"
description: "python basic study"
date: 2019-07-26
tags: [python]
comments: false
share: false
---
### 동시성

#### 동시성과 병렬성

* 동시성은 서로 독립적인 작업을 작은 단위로 나누고 번갈아 가면서 실행하는것. 즉 시분할 작업인데, 하나의 CPU에서도 가능한 것임

* 병렬성은 작업을 병렬로 처리하는 것으로 하드웨어 의존도가 높음. 반면에 동시성은 순수하게 소프트웨어 적으로 고민하게 되고, 그래서 나온 것이 `Thread` 임.

  
### Thread

#### GIL(Global Interpreter Lock)

> Thread에서는 자원의 무결성과 동기화를 위한 로직을 구현해야 하는데, GIL이 CPython에서 그런 역할을 하는 것임. 하지만 GIL때문에 thread의 기능을 완전히 수행하지 못하는데, 그 이유는 GIL이 global lock 이기 때문.
  
##### coarse-grained lock vs fine-grained lock
> 말 그대로 `coarse-grained lock`은 큰 단위로 락을 잡는 것을 말하고 `fine-grained lock`은 작은 단위로 락을 잡는 방식. CPython은 `coarse-grained lock` 이기 때문에 Cpython에서 thread를 여러개 생성하는 것이 생각보다 효율이 높지 않음.  
멀티코어 CPU에서는 `concurrent.futures.ProcessPoolExecutor`를 사용하는 것은 권장.
  
CPython에서 GIL을 사용하는 이유는 GIL이 단일 코어 환경에서는 속도가 빠르기 때문이며,
GIL이 CPU bound에서는 취약하지만 I/O bound에서는 영향이 적음.

#### Thread 구현
python에서는 저수준 thread library와 고수준 thread library를 지원하는데,  
* 저수준 라이브러리(`thread`, `_thread`)는 thread pool이나 lock을 customizing 할 수 있지만 복잡하고 어려우며 POSIX thread 환경에서만 동작한다. 수준 
* 고수준 라이브러리는 `threading`을 사용


``` python
#  basic threading function
import threading

def worker(count):
    print("name: %s, argument: %s " %(threading.currentThread().getName(), count))

def main():
    for i in range(5):
        t = threading.Thread(target = worker, name='thread %i' % i, args=(i,))
        t.start()

if __name__ == "__main__":
    main()
```

thread를 만드는 것은 비교적 간단한데, 
thread로 처리할 함수를 넣고서 초기화 한후 start( )를 부르면 됨. 그런데 실행해 보면 실행 할때마다 결과다 다르게 나옴.

``` bash
name: thread 0, argument: 0 name: thread 1, argument: 1 
name: thread 2, argument: 2 name: thread 3, argument: 3 
name: thread 4, argument: 4 
```

위와 동일한 예제를 `threading.Thead` 클래스에 등록해서 thread를 구현할 수도 있음.

``` python
#  basic threading function
import threading

class worker(threading.Thread):
    def __init__(self, args, name=''):
        threading.Thread.__init__(self)
        self.args = args
    
    def run(self):
        print("name: %s, argument: %s " %(threading.currentThread().getName(), self.args[0]))
    
def main():
    for i in range(5):
        t = worker(name='thread %i' % i, args=(i,))
        t.start()

if __name__ == "__main__":
    main()
```

> 1. Worker class를 만들고 `threading.Thread`모듈을 상속받음
> 2. 생성자에서 상속받은 `threading.Thread`의 생성자를 호출
> 3. run 메서드를 만들었는데, start( )를 호출하게 되면 내부적으로 run을 호출하게 됨

#### Thread Logging

> python2에선 print 함수가 thread safe 한 함수가 아닌데, python3에선 thread safe 하도록 변경됨. 이를 위해 `logging` 모듈을 사용하는 것을 권장함

``` python
import threading
import logging

logging.basicConfig(level=logging.DEBUG, format="name: %(threadName)s, argument : %(message)s")

def worker(count):
    logging.debug(count)

def main():
    print('called main')
    for i in range(5):
        t = threading.Thread(target = worker, name='thread %i' % i, args=(i,))
        t.start()
        
if __name__ == "__main__":
    main()
```
> 실행 결과는 다음과 같다

> ``` bash
> (thread 0) 0
> (thread 3) 3
> (thread 2) 2
> (thread 1) 1
> (thread 4) 4
```

#### Daemon Thread

> 주요 작업은 main thread에서 처리하고 백그라운드에서 처리할 작업은 daemon으로 생성해서 띄울 수 있음. 백그라운드에서 처리할 것을 thread로 실행하면 그 thread가 종료 될 때까지 main 프로그램은 종료되지 않음.

``` python
# daemon thread

import time
import logging
import threading

logging.basicConfig(level=logging.DEBUG, format="(%(threadName)s) %(message)s")

def daemon():
    logging.debug("Start")
    time.sleep(5)
    logging.debug("Exit")

def main():
    t = threading.Thread(name="daemon", target=daemon)
    t.setDaemon(True)
    t.start()

if __name__=="_main__":
    main()
    print('end of main')
```
> ~~위 예제를 실행하면 'Start' 란 메시지만 출력하고 종료됨. 'Exit'도 출력될 것을 기대했지만 그렇게 안되는데, 그 이유는 main process가 종료 되었기 때문임.~~ 
  
막상 실행해 보면 5초후에 'Exit'가 출력됨. `t.setDaemon(False)`로 해도 동일한 결과.  
main 프로그램이 먼저 종료 되고, 5초후에 daemon thread가 종료됨

``` bash
(daemon) Start
end of main
(daemon) Exit
``` 

``` python
# daemon thread with join

import time
import logging
import threading

logging.basicConfig(level=logging.DEBUG, format="(%(threadName)s) %(message)s")

def daemon():
    logging.debug("Start")
    time.sleep(5)
    logging.debug("Exit")
    
def main():
    t = threading.Thread(name="daemon", target=daemon)
    t.setDaemon(True)
    t.start()
    t.join()

if __name__ == "__main__":
    main()
    print('end of main')
```

> join을 추가하면 아래와 같이 daemon thread가 종료된 이후에 main 프로그램이 종료됨.  
즉 daemon thread가 종료될 때 까지 main 프로그램이 멈춰 있음

``` bash
(daemon) Start
(daemon) Exit
end of main
```

### Thread Event

threading 모듈에서는 thread간 간단한 통신을 위해서 `event`를 사용함.

``` python# thread_event

import time
import logging
import threading

logging.basicConfig(level=logging.DEBUG, format="(%(threadName)s) %(message)s")

def first_wait(e1, e2):
    while not e1.isSet():
        event = e1.wait(1)
        logging.debug("Event status : (%s)", event)
        
        if event:
            logging.debug("e1 is set.")
            time.sleep(1)
            logging.debug("set e2")
            e2.set()
    logging.debug('first exit')
            
def second_wait(e2):
    while not e2.isSet():
        event = e2.wait(1)
        logging.debug("event status : (%s)", event)
        
        if event:
            logging.debug("e2 is set")
    logging.debug('second exit')
    
def main():
    e1 = threading.Event()
    e2 = threading.Event()
    
    t1 = threading.Thread(name="first", target = first_wait, args=(e1,e2))
    t1.start()
    
    t2 = threading.Thread(name="second", target=second_wait, args=(e2,))
    t2.start()
    
    logging.debug("Wait ...")
    time.sleep(5)
    logging.debug("end fo sleep(5)")
    logging.debug("Set e1")
    e1.set()
    time.sleep(5)
    logging.debug("Exit")
    
if __name__ == "__main__":
    main()
```

조금 복잡하지만 실행 결과는 다음과 같음.
``` bash
(MainThread) Wait ...
(second) event status : (False)
(first) Event status : (False)
(second) event status : (False)
(first) Event status : (False)
(second) event status : (False)
(first) Event status : (False)
(second) event status : (False)
(first) Event status : (False)
(MainThread) end fo sleep(5)
(MainThread) Set e1
(first) Event status : (True)
(first) e1 is set.
(second) event status : (False)
(first) set e2
(first) first exit
(second) event status : (True)
(second) e2 is set
(second) second exit
(MainThread) Exit
```
> 1. main thread에서 thread event 객체를 만듬
> 2. main thread에서 5초간 sleep 하지만, first thread와 second thread에서 각각 로그 출력
> 3. first thread와 second thread에서 `wait(1)` 로 되어 있는데, 1초간 대기한 다음에 event의 값을 반환.
> 4. 만약 `wait()`처럼 인자가 없다면 block 상태가 되고 event 가 발생할 때 까지 대기. 즉 While loop가 실행되지 않음
> 5. e1 이 설정되면 first thread는 e2 를 설정하고 종료


### Thread Lock

``` python
# thread lock

import time
import logging
import threading

logging.basicConfig(level=logging.DEBUG, format="(%(threadName)s) %(message)s")

def blocking_lock(lock):
    logging.debug('start blocking lock')
    
    while True:
        time.sleep(1)
        lock.acquire()
        try:
            logging.debug("Grab it")
            time.sleep(0.5)
        finally:
            logging.debug("Release")
            lock.release()

def nonblocking_lock(lock):
    logging.debug("start nonblocking lock")
    
    attempt, grab = 0, 0
    while grab < 3:
        time.sleep(1)
        logging.debug("Attempt")
        success = lock.acquire(False)
        
        try:
            attempt += 1
            if success:
                logging.debug("Grab it")
                grab += 1
        finally:
            if success:
                logging.debug("Release")
                lock.release()
    logging.debug("Attempt: %s, grab: %s" % (attempt, grab))

def main():
    lock = threading.Lock()
    blocking = threading.Thread(target=blocking_lock, name="blocking", args=(lock,))
    blocking.setDaemon(True)
    blocking.start()
    
    nonblocking = threading.Thread(target=nonblocking_lock, name="nonblocking", args=(lock,))
    nonblocking.start()
    
if __name__=="__main__":
    main()
```
> 두개의 thread를 띄워서 lock을 잡도록 하였는데, blocking tread는 daemon 으로 동작하면서 lock을 잡을 때까지 blocking 상태로 되어 있는데 `acquire()`가 lock을 잡기위한 메서드임. `acquire()`에 인자가 없어 기본적으로 lock을 잡을때까지 block 됨  

> nonblocking thread에서는 lock을 잡으려고 하는 시도와 lock을 얻은 횟수를 기록함. 그리고 3번 lock을 얻었으면 동작을 종료함.  
`acquire(False)` 로 되어 있는데 인자가 `False`이기 때문에 block되지 않고 그대로 진행함.

> 실행 결과는 다음과 같음.
``` bash
(nonblocking) start nonblocking lock
(blocking) Grab it
(nonblocking) Attempt
(blocking) Release
(nonblocking) Attempt
(nonblocking) Grab it
(nonblocking) Release
(blocking) Grab it
(blocking) Release
(nonblocking) Attempt
(nonblocking) Grab it
(nonblocking) Release
(blocking) Grab it
(nonblocking) Attempt
(blocking) Release
(nonblocking) Attempt
(nonblocking) Grab it
(nonblocking) Release
(nonblocking) Attempt: 5, grab: 3
(blocking) Grab it
(blocking) Release
```


### Thread Reentrant Lock

재 진입 가능한 lock 이란 말인데, 특정 thread가 lock을 잡더라도 다른 thread에서 `acquire'를 할 수 있는 lock을 말함.

``` python
# thread rlock

import time
import logging
import threading

logging.basicConfig(level=logging.DEBUG, format="(%(threadName)s) %(message)s")

RESOURCE = 0

def set_reverse(lock):
    logging.debug('Start batch')
    
    with lock:
        logging.debug('Grab lock')
        
        if RESOURCE == 0:
            set_one(lock, True)
        else:
            set_zero(lock, True)
    logging.debug('Reversed')

def set_zero(lock, end=False):
    logging.debug('Start set zero')
    
    while True:
        with lock:
            logging.debug("grab lock and set RESOURCE to 0")
            RESOURCE = 0
            time.sleep(0.5)
        time.sleep(1)
        
        if end:
            break

def set_one(lock, end=False):
    logging.debug('Start set one')
    
    while True:
        with lock:
            logging.debug('grab lock and set RESOURCE to 1')
            RESOURCE = 1
            time.sleep(0.5)
        time.sleep(1)
        
        if end:
            break
            
def main():
    lock = threading.RLock()
                          
    zero = threading.Thread(target=set_zero, name="zero", args=(lock,))
    zero.setDaemon(True)
    zero.start()

    one = threading.Thread(target=set_one, name="one", args=(lock,))
    one.setDaemon(True)
    one.start()    
                          
    time.sleep(6)
                          
    reverse = threading.Thread(target=set_reverse, name="reverse", args=(lock,))
    reverse.start()
    
if __name__=="__main__":
    main()
```

update : 2019-07-28. 출처:[파이썬답게 코딩하기](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=143094231)